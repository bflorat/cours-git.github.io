<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
                <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Cours génie logiciel Licence Pro 2022-2023, la gestion de versions">
	<meta name="author" content="Bertrand Florat">

    <title>Cours Génie Logiciel Licence Pro 2022-2023, la gestion de versions</title>

    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/moon.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
    <link rel="stylesheet" href="css/custom.css" id="custom">
	</head>

	<body>

	<div class="reveal">
		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">

			<!-- Introduction -->
			<section>
				<h2>La gestion de versions</h2>
				<p>IUT de Nantes – Département Informatique</p>
				<p>
					<b>Cours de Licence professionnelle 2022-2023</b>
				</p>
				<div>
					<p style="font-size:0.5em;text-align: center;">Copyright (C) 2012-2021 Bertrand Florat (
						<a href='http://www.florat.net/contact'>contact</a>), licence
						<a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA V4</a>
					</p>
					<p style="font-size:0.5em">
						<a href="https://cours-git.florat.net/">https://cours-git.florat.net/</a>
						/
						<a href='tp.html'>Feuille de TP</a>
						/
						<a href='https://github.com/bflorat/cours-git.github.io'>Sources</a>
						/
						<a href='index.html?print-pdf'>(version sur une page)</a>

					</p>
				</div>
				<div>
					<img src="https://pbs.twimg.com/media/CqzJkJ_VYAA5CtM?format=jpg&name=small" height='500px'/>
					<figcaption>Source : <a href='https://pbs.twimg.com/media/CqzJkJ_VYAA5CtM?format=jpg&name=small'>https://pbs.twimg.com</a></figcaption>
				</div>
			</section>
			<section style="font-size: 0.5em">
				<h3>Agenda</h3>
				<table>
					<tr class="title">
						<td>1- Concepts généraux</td>
						<td>2- Présentation de Git</td>
						<td>3- Pratique de Git</td>
						<td>4- Travail collaboratif avec Git</td>
					</tr>
					<tr>
						<td>
							<ul>
								<li class="tp">TP1 : Motivations</li>
								<li>Rôle dans l'usine logicielle</li>
								<li>Notions et terminologie</li>
								<li>Règles de l'art VCS</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>Concepts Git</li>
								<li class="tp">TP2: Exercice concepts Git</li>
							</ul>
						</td>

						<td>
							<ul>
								<li>Commandes de base</li>
								<li>Règles de l'art Git</li>
								<li class="tp">TP3 : commandes de base en équipe</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>Outils</li>
								<li>Les différents types de workflows</li>
								<li class="tp">TP4 : utilitaires Git</li>

							</ul>
						</td>
					</tr>
				</table>
			</section>

			<section>
				<h3>Pour optimiser ce cours</h3>
				<h4>Comment bien apprendre ?<h4>
				<img src="images/apprendre.png" width="800px">
			</section>

			<section>
				<h3>Note sur Subversion</h3>
				<p>Ce cours a intégré SVN en plus de Git de 2012 à 2016.</p>
				<p>En cas de besoin,
					<a href='https://public.florat.net/cours_vcs_2016/cours.html'>l'ancien cours</a> est toujours disponible.
				</p>
			</section>

			<!-- Slot 1 -->
			<section>
				<h3>Motivations</h3>
				<p class="note" style="color: green">TP1 : Que serait notre vie sans VCS ?</p>
				<p>Vous faites partie d’une équipe de développement qui intervient sur la réalisation d’une application
				</p>
				<ul>
					<li class="fragment">Comment s'assurer de ne pas perdre de sources ?</li>
					<li class="fragment">Comment conserver l’historique et revenir en arrière ?</li>
					<li class="fragment">Comment partager le développement entre plusieurs personnes ? </li>
					<ul>
						<li class="fragment">avec des contributeurs externes ?</li>
					</ul>
					<li class="fragment">Comment gérer plusieurs variantes à la fois ?
						<aside class="notes">Versions de maintenance, experimentation de nouvelles fonctionnailités, plusieurs clients...
						</aside>
					</li>
					<li class="fragment">Comment tracer les modifications ?</li>
					<li class="fragment">Comment valider les modifications et faire de la revue de code ?</li>
					<li class="fragment">Comment fusionner les modifications ?</li>
				</ul>
				<br />
				<p class="fragment">
					<b>En utilisant un VCS !</b>
				</p>
			</section>

			<section>
				<h3>Le VCS au sein de l'usine logicielle</h3>
				<img src="images/UsineLogicielle.png" width="1000px">
			</section>

			<section>
				<h3>Usage</h3>
				<ul>
					<li>Utilisateurs : les développeurs et les intégrateurs</li>
					<li>Le VCS est avec l'IDE l'outil principal du développeur</li>
					<li>Principalement stockage de fichiers
						<b>texte</b>
					</li>
				</ul>
			</section>

			<section>
				<h4>Quels fichiers dans le dépot ?</h4>
				<p>
					<b>Régle no 1 : le projet doit être auto-porteur</b>
				</p>
				<p>
					<b>Régle no 2 : on ne commit pas de fichiers dérivés</b>
				</p>
				<div style="font-size: 0.5em">
					<p style="font-weight: bold">A commiter</p>
					<ul>
						<li>Fichiers source (.java, .c, .html, .css...)</li>
						<li>Fichiers binaires non dérivés des sources, images par exemple</li>
						<li>Jeux de données des tests</li>
						<li>Fichiers de build (maven: pom.xml, npm: package.json, Jenkinsfile ...)</li>
					</ul>
					<br />
					<p style="font-weight: bold">A ne pas commiter :</p>
					<ul>
						<li>Fichiers temporaires, générés ou compilés</li>
						<li>Librairies (utiliser un dépot Maven)</li>
					</ul>
					<br />
					<p style="font-weight: bold">Selon les politiques :</p>
					<ul>
						<li>Fichiers projets de l'IDE (.project, .idea ...)</li>
						<li>Personnalisation et historique de l'IDE</li>
					</ul>
				</div>
			</section>

			<section>
				<h3>Modeles centralisés / client-serveur</h3>
				<div style="width: 500px; font-size: 50%; text-align: left; float: left !important; margin-right: 20px !important; margin-top: 0px !important;">
					<img src="images/modele_central.png" />
					<figcaption>Copyright CC-BY-NC-SA Mathieu Nebra (M@teo21)</figcaption>
				</div>
				<p>Exemples : CVS, SVN, ClearCase, Perforce</p>
				<p>Un serveur gère l'intégralité des révisions (le dépôt), les développeurs récupèrent les modifications des autres et y
					ajoutent les leurs</p>
			</section>
			<section>
				<h3>Modeles distribués</h3>
				<div style="width: 500px; font-size: 50%; text-align: left; float: left !important; margin-right: 20px !important; margin-top: 0px !important;">
					<img src="images/modele_distribue.png" />
					<figcaption>Copyright CC-BY-NC-SA Mathieu Nebra (M@teo21)</figcaption>
				</div>
				<p>Exemples : Git, Mercurial, Baazar, BitKeeper</p>
				<p>Chaque développeur possède un dépôt entier mais les dépôts peuvent s'échanger des modifications</p>
			</section>

			<section>
				<h4>Concepts généraux</h4>
				<table>
					<tr>
						<td>SCM,
							<b>VCS</b>, outil de versioning, GCL
						</td>
						<td>Source Control Management, Version Control System : outils permettant de gérer plusieurs versions de sources</td>
					</tr>
					<tr>
						<td>
							<b>dépôt</b>, référentiel [repository, depot]</td>
						<td>Un dépôt est une sortie de base de données de sources contenant toutes les révisions (tout l'historique) des fichiers
							ainsi que des données de gestion (méta-données) associées.
							<b>On ne peut rien perdre dans un dépot.</b>
						</td>
					</tr>
				</table>
			</section>
			<section>
				<h4>Concepts généraux</h4>
				<table>
					<tr>
						<td>
							<b>Copie locale</b>, espace de travail [working copy/directory/workspace]
						</td>
						<td>Copie locale éditable d'une révision du dépôt et dont les modifications peuvent ensuite être validées (commitées) dans
							le dépôt. Sert de 'bac à sable'.</td>
					</tr>
					<tr>
						<td>
							<b>Commit</b>, validation,
							<br />"mettre en conf", [commit,checkin]</td>
						<td>(verbe) Enregistrer des modifications de la copie locale vers dépôt.
							<br />(nom) modifications elles-mêmes.
						</td>
					</tr>

				</table>
			</section>

			<section>
				<h4>Concepts généraux</h4>
				<table>
					<tr>
						<td>
							<b>Branche</b> [branch]</td>
						<td>
							<p>Une ligne de développement d'un projet. Sert par exemple à</p>
							<ul>
								<li>Gérer une version spécifique pour un client</li>
								<li>Gérer des branches de maintenance corrective</li>
								<li>Ecrire une fonctionnalité ou un correctif en isolation</li>
								<li>Tester une idée, un refactoring sans risques</li>
							</ul>
							<br/><br/>
							<span class='note'>Attention, les branches ne sont pas toujours adaptées. 
							<br/>Une alternative à certains types de branches se développe : Le Trunk-Based Developement 
							<br/>dans lequel les developpeurs envoient tous leur code dans une seule et unique branche 
							<br/>mais dont certaines fonctionnalités sont désactivées par
								<a href='https://martinfowler.com/articles/feature-toggles.html'>feature flags (ou "feature toggles")</a>.								
						</td>
					</tr>					
				</table>
			</section>

			<section style="font-size: 25px">
				<h4>Concepts généraux</h4>
				<table>
					<tr>
						<td>
							<b>Merge</b>, fusion [merge]</td>
						<td>Fusion des modifications de deux branches
							<img src="images/branches.png" />
						</td>
					</tr>
					<tr>
						<td>
							<b>Tag</b>, étiquette [tag, label]</td>
						<td>Photo du dépôt à un moment précis. Etiquette d'un ensemble cohérent de sources.
							<p class="note">Un tag peut présenter un aspect contractuel (signature numérique)</p>
						</td>
					</tr>

				</table>
			</section>
			<section>
				<h4>Concepts généraux</h4>
				<table>
					<tr>
						<td>
							<b>Modification concurrente</b>
						</td>
						<td>
							<p>Tentative de mise à jour de sources ayant divergées</p>
							<div>
								<img src="images/collision.png" width="500px" />
								<figcaption>CC-BY-SA Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato
								</figcaption>
							</div>
						</td>
					</tr>
				</table>
			</section>
			<section>
				<h4>Concepts généraux</h4>
				<table>
					<tr>
						<td>
							<b>Conflit</b> [conflict]</td>
						<td>

							<p>Modification concurrente d'une même zone de texte. La résolution est manuelle.</p>
							<p>Exemple de conflit :</p>
							<pre style="z-index: -1; float: hidden; margin: 0px">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; commit A'
int i = 0;
=======
int i = 1;
int j=0;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; commit A''</pre>
						</td>
					</tr>

				</table>
			</section>
			<section>
				<h5>Bonnes pratiques</h5>
				<ul>
					<li>Le code commité doit toujours compiler</li>
					<li>Commiter et merger souvent, mettre à jour régulièrement</li>
					<li>Utiliser avec un outil de gestion de tickets (Issues GitLab / GitHub, Jira, Trac, Mantis...)
					</li>
					<li>Grouper les modifications en commits cohérents</li>
					<li>Ne jamais commiter de secrets</li>
					<li>Ne jamais commiter du code mort (en commentaire ou pas)</li>
					<li>Formatage coercitif des sources ASAP</li>
				</ul>
			</section>
			<section>
				<h5>Bonne pratiques / numéros de versions</h5>
				<ul>
					<li>Version scheme :
						<span class='lcode'>[X].[Y].[Z]</span>, exemple :
						<span class='lcode'>1.2.3</span>
					</li>
					<li>Programme : [major (refonte complète)].[minor (évolution)].[no fix (correction) en partant de zéro]
					</li>
					<li>Librairie : [compatibilite API].[évolution].[fix]</li>
					<li>Voir le semantic versionning
						<a href="http://semver.org/">http://semver.org/</a>
					</li>
				</ul>
			</section>

			<section>
				<h5>Bonnes pratiques / convention message de commit</h5>
				<ul>
					<li>Un titre (max 50 caractères) sous la forme
						<a href='https://github.com/angular/angular/blob/master/CONTRIBUTING.md#type'>type de commit
						</a>: contenu</li>
					<li>Un paragraphe détaillé (largeur 72 caractères max)</li>
				</ul>

				<p>Rédaction du contenu:</p>
				<ul>
					<li>Lignes vides entre paragraphes</li>
					<li>Si clos un ticket, l'indiquer, exemple :
						<span class='lcode'>Closes #1234</span>
					</li>
					<li>Présent : "corrige", pas "a été corrigé"</li>
					<li>Donner toute information importante à destination d'un futur mainteneur</li>
					<li>Exemple :</li>
					<pre>
fix: problème fichier bootstrap vide

Closes #1456

Corrige une NPE se produisant quand le fichier bootstrap existe 
mais est vide. Reproduit uniquement par TU, non reporté par les 
utilisateurs à ce point. 

Voir aussi le bug #1674.
						</pre>
				</ul>

				<p class='note'>Note: pour faire un message de commit multiligne sous Linux/OSX en ligne de commande : utiliser l'options -m " puis " 
					à la fin de la dernière ligne)</p>
			</section>

			<!--  Slot 3 -->
			<section>
				<h4>Introduction à Git</h4>
				<div>
					<img src="images/git-logo.svg.png" height="150px" />
				</div>
				<ul>
					<blockquote>I'm an egotistical bastard, and I name all my projects after myself. First Linux, now Git. (Linus Torvalds)
					</blockquote>
					<li>Linus Torvalds + 3 semaines = Git (utilisé pour le kernel Linux dès avril 2005)
					</li>
					<li>VCS le plus puissant et le plus performant mais non trivial
					</li>
					<li>Open Source (licence GPL)</li>
					<li>VCS de type distribué et contrôle optimiste uniquement</li>
					<li>Programme "Unix-like" : commandes de haut niveau (porcelain) utilisant commandes bas niveau (plumbing)
					</li>
				</ul>
			</section>
			<section>
				<h4>Quelques clients Git</h4>
				<ul>
					<li>
						<b>Tous OS</b>: egit/jgit, IDEA, ATOM, Visual Studio Code, GitKraken, ungit (node.js)...</li>
					<li>
						<b>Linux</b>: git (ligne de commande) + gitk (GUI pour l'historique), tig (ncurses), </li>
					<li>
						<b>Microsoft Windows</b>: Git for Windows (git en ligne de commande), TurtoiseGit (éditeur graphique intégré dans l'OS)
					</li>
					<li>
						<b>Mac OSX</b> : Tower, GitBox </li>
					<li>
						<b>Web</b> : GitHub, GitLab, Gitea </li>
				</ul>
				<img src="images/egit.png" width="300px" />

			</section>
			<section>
				<h4>Configurer git</h4>
				<p class='note'>Attention! ne surtout pas oublier de configurer Git avant tout commit, plus possible ensuite de changer nom/e-mail (sauf
					perte historique)</p>
				<p>Trois niveaux de configuration :
					<ul>
						<li>
							<span class='lcode'>/etc/gitconfig</span> : configuration multi-dépôt pour tous les utilisateurs de la machine</li>
						<li>
							<span class='lcode' style="font-weight: bold">~/.gitconfig</span> : configuration multi-dépôt pour l'utilisateur (en général, seul ce fichier est à modifié)
						</li>
						<li>
							<span class='lcode'>/
								<i>chemin dépôt</i>/.git/config
							</span> : configuration du dépôt</li>
					</ul>
					<p>Configuration globale (multi-dépôts) de l'utilisateur courant :</p>
					<pre>
$ git config --global user.name "John Doe"  //<i>Obligatoire !</i>
$ git config --global user.email johndoe@example.com   //<i>Obligatoire !</i>
					</pre>
				</p>
				<p class='note'>Autres exemples de configuration :
					<span class="lcode">core.editor</span> ou
					<span class="lcode">merge.tool</span>
				</p>
			</section>

			<section>
				<h5>Les alias</h5>
				<pre>git config --global alias.co checkout</pre>
				<p>A mettre dans la section
					<span class='lcode'>[alias]</span> de
					<span class='lcode'>~/.gitconfig</span>
				</p>
				<p>Les plus courants :</p>
				<pre>
cp = cherry-pick
st = status -s
cl = clone
ci = commit
co = checkout
br = branch
po = push origin
</pre>
			</section>

			<section>
				<h5>Création d'un nouveau dépôt</h5>
				<p class='note'>Note : un seul projet par dépôt pour raison d'isolation et de performances</p>
				<pre>$ cd ~/depots/my-app
$ git init</pre>
				<p>Le contenu du répertoire (projet Maven/Eclipse) sera :</p>
				<pre>
~/depots/my-app
                   /.git  <i>//dossier des meta-données git</i>
                   /.project
                   /.classpath
                   /pom.xml
                   /src/main/java
                   /...
</pre>
				<br />
				<p>Dépôt nu (sans copie locale) :</p>
				<ul>
					<li>Créé avec :
						<span class="lcode">git init --bare</span>
						<li>Convention nommage : repertoire
							<span class="lcode">my-app
								<b>.git</b>
							</span>
						</li>
					</li>
				</ul>

			</section>
			<section>
				<h5>Récupération d'un dépôt existant</h5>
				<pre>$ git clone <i>url</i></pre>
				<p>Juste le dernier commit de chaque branche :
					<span class='lcode'>--depth 1</span>
				</p>
				<p>Format des URLs :</p>
				<pre>
ssh://[user@]host.xz[:port]/path/to/repo.git/
git://host.xz[:port]/path/to/repo.git/
http[s]://host.xz[:port]/path/to/repo.git/
ftp[s]://host.xz[:port]/path/to/repo.git/
rsync://host.xz/path/to/repo.git/
file:///path/to/repo.git/  =  /path/to/repo.git/
</pre>
				<p>
					Le dépôt que l'on vient de cloner est spécial : il est appelé
					<span class='lcode'>
						<b>origin</b>
					</span> (
					<i>upstream repository</i>)
				</p>
			</section>
			<section>
				<h4>Structure de base de Git</h4>
				<ul>
					<li>Git stocke des :
						<i>trees</i>,
						<i>blobs</i>,
						<i>tags</i> et
						<i>commits</i>, tous référencés par un hash SHA-1 unique (intégrité)
					</li>
					<li>Les références (refs) sont des noms symboliques (signets) des hashs des commits</li>
				</ul>
				<img src="images/tree.png" width="700px" />
				<p style="font-size: small; text-align: center">
					<i>Copyright CC BY-SA-NC Scott Chacon</i>
				</p>
				<p class='note' style="font-size: 0.5em !important;">
					SHA-1 transforme une suite de caractères de 1 à 2^64 bits en un nombre de 160 bits. Non réversible. Exemple :
					<span class='lcode'>a6e757a90e389270e75428473858e04f8c71121b</span>. Versions réduites :
					<span class='lcode'>a6e757a</span>. Risque collisions infinitésimaux.
				</p>
			</section>

			<section>
				<h4>Les commits dans Git</h4>
				<ul>
					<li>Un commit est un <b>instantané de l'ensemble du dépot</b>
						 (contrairement à certains VCS comme SVN où un commit est un diff depuis le commit précédent)</li>
					<li>Chaque commit possède [1..n] parents</li>
					<li>Donc l'historique forme un graphe (orienté et acyclique ou 'DAG')</li>
					<li>Le commit est de niveau dépôt (pointe sur le tree racine)</li>
					<li>Notation :
						<span class='lcode'>ref^<i>n</i>
						</span> (nième parent) et
						<span class='lcode'>ref~<i>n</i>
						</span> (nième premier parent)</li>
				</ul>
				<img src="images/dag.png" width="600px" />
				<figcaption>Copyright CC BY-SA-NC Scott Chacon</figcaption>


			</section>
			<section>
				<h4>Branching</h4>
				<ul>
					<li>Pseudo-branche = ref (pointeur) vers un commit</li>
					<li>Créer une branche (fork) et s'y positionner :
						<pre>
$ git branch mabranche
$ git checkout mabranche
ou : $ git checkout -b mabranche
ou (nouvelle commande) : $ git switch mabranche 
</pre>
					</li>
					<li>Note : si changement de branche avec des modifications non commitées, git fusionne le contenu des copies locales sauf
						si conflit detecté.</li>
				</ul>
			</section>
			<section>
				<h4>Branching (suite)</h4>
				<ul>
					<li>Branche 'HEAD' = ref vers branche courante</li>
					<img src="images/git-branching.png" width="600px" />
					<figcaption>Images Copyright CC BY-SA-NC Scott Chacon</figcaption>
					<li>Conventions :
						<ul class="small">
							<li>
								<span class='lcode'>master</span> : branche par défaut</li>
							<li>
								<span class='lcode'>develop</span> : branche de développment (instable)</li>
							<li><span class='lcode'>feat-ma-fonctionnalite</span> : une branche topic de nouvelle fonctionnalité</li>
							<li><span class='lcode'>fix-1234</span> : une branche topic de correctif</li>
						</ul>
					</li>
				</ul>
			</section>
			<section>
				<h4>Merge de branches</h4>
				<table>
					<tr>
						<td style="border-style: none !important;">
							<ul>
								<li>Merge branche
									<span class='lcode'> develop</span> dans la branche
									<span class='lcode'> master</span> (courante):
									<pre>$ git merge develop</pre>
								</li>
								<li>Applique tous les commits de
									<span class='lcode'>develop</span>
									dans
									<span class='lcode'>master</span> depuis le dernier merge entre ces deux branches.
								</li>
								<li>Si la branche courante n'a pas évolué depuis dernier merge, fast-forward (ff)</li>
								<li>Si divergence (non-ff), merge automatique. Conflits possibles
								</li>
							</ul>
						</td>
						<td style="border-style: none !important">
							<div style="display: table-cell;vertical-align:top !important">
								<img src="images/branch-ff.png" width="600px" />
								<img src="images/branch-non-ff.png" width="600px" />
								<figcaption>Images Copyright CC BY-SA-NC Scott Chacon</figcaption>
							</div>
						</td>
					</tr>
				</table>

			</section>

			<section>
				<h4>Branches remote</h4>
				<ul>
					<li>Branche remote (distante) : branche locale cache d'une branche d'un dépôt distant
						<p>
							<b>Attention ! ce n'est qu'une
								<i>image</i>, un
								<i>proxy</i> de la branche distante, elle n'est pas rafraichie tant qu'on n'a pas fait un
								<span class='lcode'>git fetch</span>
							</b>
						</p>
					</li>
					<li>Exemples :
						<pre>
remotes/origin/HEAD -&gt; origin/master
remotes/origin/develop
remotes/origin/master
remotes/bob/feature300</pre>
					</li>
					<li>Lecture seule, se resynchronise avec son dépôt distant avec
						<span class='lcode'>git fetch</span> et
						<span class='lcode'>git push
						</span>
					</li>
				</ul>

			</section>
			<section>
				<h4>Branches remote (suite)</h4>
				<ul>
					<li>Par défaut, push refusé si la branche distante a divergé</li>
					<li>
						<span class='lcode'>git pull</span> =
						<span class='lcode'>git fetch
						</span> + <span class='lcode'>git merge</span>
					</li>
					<li>
						<span class='lcode'>git pull --rebase</span> =
						<span class='lcode'>git fetch
						</span> +
						<span class='lcode'>git rebase</span>
					</li>
					<li>Tracking remote branch : branche remote avec refspec, push/fetch/pull sans arguments (le '+' signifie qu'on met à jour
						la référence même si ce n'est pas un ff)
						<pre>
[remote "origin"]
url=git@gitorious.org:/my-app.git
fetch=+refs/heads/*:refs/remotes/origin/*
pull=refs/heads/*:refs/remotes/origin/*
push = refs/heads/master:refs/heads/qa/master</pre>
					</li>
					<li>Après un
						<span class='lcode'>git clone</span>, branches tracking remote automatiquement créées :
						<span class='lcode'>refs/origin/
							<i>branche</i>
						</span>
					</li>
				</ul>

			</section>
			<section>
				<h4>Branches remote</h4>
				<img src="images/remotes.png" width="800px" />
			</section>
			<section>
				<h4>Tags</h4>
				<ul>
					<li>Un tag est une référence sur un commit + un auteur + un message + une signature numérique optionnelle
					</li>
					<li>Vrai élement du dépôt</li>
					<li>Créer un tag (option
						<span class='lcode'>-a</span> : "annoted"):
						<pre>$ git tag -a 1.0.0 -m 'Version  1.0'</pre>
					</li>
					<li>Attention, tags non poussés par défaut :
						<pre>$ git push --tags</pre>
					</li>
					<li>Lister les tags :
						<pre>git tag -l</pre>
					</li>
				</ul>
				<p class='note'>Git supporte aussi des tags légers locaux (lightweight) qui sont simplement des branches en lecture seule. A éviter pour les livraisons officielles.</p>

			</section>
			<section>
				<h4>Cycle de vie d'un fichier dans la copie locale</h4>
				<ul>
					<li>Index (ou "staging area") : sas (facultatif) de "pré-commit"</li>
					<li>Permet de sélectionner les modifications à commiter</li>
					<li>Débrayable avec l'option
						<span class='lcode'>-a</span>
						de
						<span class='lcode'>git commit</span>
					</li>
					<li>Attention : il faut obligatoirement faire
						<span class='lcode'>git add</span> pour un nouveau fichier</li>
					<li>Status des fichiers :
						<span class='lcode'>git status
						</span>
					</li>
					<li>Une fois prêt, commit :
						<span class='lcode'>git commit</span>
					</li>
					<li>Commit interactif de partie de fichier avec l'option
						<span class='lcode'>-p</span> (patch)
					</li>
				</ul>
				<img src="images/lifecycle.png" width="800px" />
			</section>

			<section>
				<h5>TP2 Exercice concepts Git</h5>
				<p class="note">Voir la feuille de travaux pratiques</p>
			</section>

			<!-- Slot 4 -->
			<section>
				<h4>Commandes git de base</h4>
				<p class="note">
					Voir aussi la cheat sheet
					<a href="http://ndpsoftware.com/git-cheatsheet.html">[5]</a>
				</p>
				<br />
				<ul>
					<li>Commandes de changement de statut de la copie locale :
						<span class='lcode'>checkout [-m]</span>,
						<span class='lcode'>add</span>,
						<span class='lcode'>rm</span>,
						<span class='lcode'>mv</span>,
						<span class='lcode'>commit</span>,
						<span class='lcode'>stash</span>
					</li>
					<li>Commandes de correction :
						<span class='lcode'>revert</span>,
						<span class='lcode'>reset (soft|mixed|hard)</span>,
						<span class='lcode'>commit --amend</span>,
						<span class='lcode'>clean</span> (supprime aussi les fichiers untracked)
					</li>
					<li>Commandes de branching :
						<span class='lcode'>branch</span>,
						<span class='lcode'>merge</span>,
						<span class='lcode'>cherry-pick</span>,
						<span class='lcode'>rebase</span>
					</li>
					<li>Commandes d'informations :
						<span class='lcode'>log</span>,
						<span class='lcode'>status</span>,
						<span class='lcode'>diff</span>,
						<span class='lcode'>show</span>,
						<span class='lcode'>blame</span>,
						<span class='lcode'>reflog</span>
					</li>
					<li>Commandes de travail sur branches distantes :
						<span class='lcode'>remote</span>,
						<span class='lcode'>push</span>,
						<span class='lcode'>fetch</span>,
						<span class='lcode'>pull</span>
					</li>
				</ul>
			</section>

			<section>
				<h4>Historique</h4>
				<ul>
					<li>Commande de base:
						<span class='lcode'>git log</span> ou souvent (avec le sha)
						<span class='lcode'>git log --oneline
						</span>
					</li>
					<li>Voir les diff de chaque révision : option
						<span class='lcode'>git log -p</span>
					</li>
					<li>Visualiser le contenu complet d'un fichier f dans une ref x :
						<span class='lcode'>git show x:f</span>
					</li>
					<li>Spécifier des intervales de temps
						<pre>git log --since=2.weeks</pre>
					</li>
					<li>Voir les diff de chaque révision : option
						<span class='lcode'>git show</span>
					</li>
					<li>Voir un graphe des révisions : option
						<span class='lcode'>git log --graph</span>
					</li>
					<li>
						<span class='lcode'>git log branche1..branche2</span> : tous les nouveaux commits de la branche2 uniquement
					</li>
					<li>Recherche d'une chaîne de caractère dans tous les fichiers de tout l'historique :
						<span class="lcode">git rev-list --all | xargs git grep [chaîne ou expression régulière]</span>						
					</li>
				</ul>
			</section>

			<section>
				<h4>Comparaison de branches</h4>
				<ul>
					<li>Comparer deux références ('..' et 'HEAD' optionnels) :
						<pre>git diff HEAD..origin/hotfix/release-1_0
git diff ..origin/hotfix/release-1_0
git diff origin/hotfix/release-1_0</pre>
					</li>
					<li>Options
						<span class='lcode'>-w</span> pour ignorer les différences de formatage
					</li>
					<li>Toutes les différences entre deux branches :
						<pre>$ git diff branche1..branche2</pre>
					</li>
					<li>Seulement les différences de la branche2 avec le dernier commit commun entre branche1 et branch2 (qu'ai-je fait dans
						la branche2 depuis que mes deux branches ont divergées ?) :
						<pre>$ git diff branche1...branche2</pre>
					</li>
				</ul>
				<p class='note'>
					Attention !
					<span class='lcode'>git diff</span> sans arguments compare copie locale et index, pas HEAD
				</p>
				<p>Liste des commits pas encore poussés :
					<pre>git cherry -v</pre>
				</p>
			</section>
			<section>
				<h5>Merging</h5>
				<pre>
$ git checkout master
$ git merge iss53</pre>
				<ul>
					<li>C'est la copie locale de la branche courante qui est modifiée
					</li>
					<li>Si conflit, plus possible de commiter :
						<ul>
							<li>Soit résolution manuelle des conflits</li>
							<li>Soit
								<span class='lcode'>git checkout --ours
									<i>fichier</i>
								</span>
							</li>
							<li>Soit
								<span class='lcode'>git checkout --theirs
									<i>fichier</i>
								</span>
							</li>
							<li>puis (dans les trois cas),
								<span class='lcode'>add</span>
								et
								<span class='lcode'>commit</span>
								<li>Revenir à l'état antérieur :
									<span class='lcode'>git reset --merge</span>
								</li>
							</li>
						</ul>
					</li>
				</ul>
				<p class='note'>
					Bonne pratique : option
					<span class='lcode'>--no-ff</span> pour créer un commit de merge même en cas de FF
				</p>
			</section>
			<section>
				<h5>Rebasing</h5>
				<img src="images/git-rebase1.png" width="400px" />
				<img src="images/git-rebase2.png" width="400px" />
				<figcaption>Images Copyright CC BY-SA-NC Scott Chacon</figcaption>
				<pre>
$ git checkout experiment; git rebase master
$ git checkout master; git merge experiment</pre>
				<ul>
					<li>Sérialise deux branches, nos commits à la fin</li>
					<li>Se "rebase" sur une référence, c'est à dire repart de cette ref</li>					
					<li>Quels avantages sur merge ? 
						<ul>
						   <li>Rend l'historique beaucoup plus lisible (linéaire)</li>
						   <li>La résolution de conflit se fait commit par commit</li>
						   <li>Plus facile de debugguer en navigant sur un historique linéaire</li>
						   <li>Tests plus fiables car on integre le code des autres dans nos tests</li>
					    </ul>
					</li>
				</ul>
				<p class="warn">Attention : n'utiliser rebase qu'avec ses branches locales, ne jamais rebaser un commit qui a déjà été poussé.</p>				
			</section>

			<section>
				<h5>Rebase interactif</h5>
				<span class='lcode'>rebase -i [commit]</span> 
				<p><b>Permet au passage de modifier l'historique (squashing, spliting, modification
						messages, changement d'ordre ...)</b></p>
				
				<li>Le commit cible est le parent du premier commit à modifier. Réorganiser les 5 derniers commits : 
				<span class='lcode'>rebase -i HEAD~5</span>  (5éme ancêtre du commit où on se trouve= 6éme commit dans le passé)</p></li>
				
				<li>Actions courantes : 
					<ul>
						<li><span class='lcode'></span>reword (r)</span> : réécrire le message de commit</li>
						<li><span class='lcode'></span>edit (e)</span> : modifier le commit</li>
						<li><span class='lcode'></span>squash (s)</span> : fusionner le commit avec le précédent</li>
						<li>Supprimer des commits/changer leur ordre en jouant sur les lignes <span class='lcode'></span>pick (p)</li><span></span></li>
					</ul>
				</li>
				
			</section>

			<section>
				<h5>Cherry-picking</h5>
				<ul>
					<li>
						<span class='lcode'>git cherry-pick commit1 commit2...</span>
					</li>
					<li>Applique les commits selectionnés comme des patchs sur la branche courante</li>
				</ul>
			</section>
			
			<!-- Slot 5  -->
			<section>
				<h4>Utilitaires</h4>
				<ul>
					<li>Rebase interactif pour réécrire son historique local
						<pre>git rebase -i</pre>
					</li>
					<li>debugage multi-révisions avec bisect
						<pre>git bisect [good|bad|start|skip|run|reset]</pre>
					</li>
					<li>Commit partiel dans un même fichier :
						<pre>git add -p</pre> (option patch)</li>
					<li>L'autocomplétion [7]. Ajouter
						<span class='lcode'>. git-completion.bash</span> dans
						<span class='lcode'>/etc/profile</span>
					</li>
					<li>L'IHM gitk</li>
					<li>Changelog avec shortlog :
						<pre>$ git shortlog</pre>
					</li>
					<li>Fancy CLI
						<ul>
							<li>Coloriser :
								<pre>git config --global ui.color true</pre>
							</li>
							son
							<span class='lcode'>.bashrc</span>
						</ul>
					</li>
					<li>Templates de messages de commit
						<pre>git config --global commit.template <i>fichier</i>
									</pre>
					</li>
				</ul>
			</section>
			<section>
				<h4>Ignorer des fichiers</h4>
				<ul>
					<li>Fichier
						<span class='lcode'>.gitignore</span> à la racine de la copie locale (lui-même commité). Exemples :
						<pre>
# a comment - this is ignored
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the root TODO file, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# Exemple réél :
.metadata
bin
build
.settings
# Ignore recursively all .class files
*.class
</pre>
					</li>
					<li>Possible de positionner un fichier
						<span class='lcode'>.gitignore</span>
						n'importe où
					</li>
					<li>Peut être défini au niveau utilisateur dans le fichier donné par
						<span class='lcode'>~/.gitconfig</span> propriété
						<span class='lcode'>core.excludesfile</span>
					</li>
				</ul>
			</section>
			<section>
				<h4>Bonnes pratiques Git, à faire</h4>
				<ul>
					<li>Configurer Git (nom et e-mail) avant tout commit</li>
					<li>Utiliser les commandes
						<span class='lcode'>git rm, git mv</span> au lieu des commandes sytème  (git fait le 'add' pour vous)
					</li>
					<li>Bloquer les push forcés et les suppressions coté serveur publique avec les options
						<span class='lcode'>receive.denyNonFastForwards=true</span>
						et
						<span class='lcode'>receive.denyDeletes</span>=true
					<li>Nettoyer (avec <span class='lcode'>rebase -i</span>) son historique avant de le pousser si confus</li>
					<li>... ou encore mieux : pusher un seul commit par branche (squash)</li>
					<li>N'utiliser rebase que sur des commits pas encore poussés</li>
					<li>Créer une branche topic (vie courte) pour chaque unité de travail (bug, évolution...)</li>
					<li>Protéger (empècher les push directs sans MR) les branches à vie longue (<span class='lcode'>master</span>, <span class='lcode'>develop</span>...)</li>
					<li>Les branches topic ne doivent pas vivre plus de un à deux jours et doivent être supprimées dès que mergées</li>
					<li>Travailler avec des Merge Requests si vous disposez d'une forge (ex: Gitlab)</li>
					<li>Squasher les commits de MR (une MR = 1 commit)</li>					
				</ul>
			</section>

			<section>
				<h4>Bonnes pratiques Git, à éviter</h4>
				<ul>
					<li>Pas de merge avec modifications non commitées (retour arrière difficile)</li>
					<li>Ne pas forcer les push (avec push -f ou via l'option + des refspecs), risque de perte de commits
					</li>
					<li>Ne pas modifier (avec rebase ou --ammend) un commit publié</li>
					<li>Ne pas mixer merges et rebases, rend les résolutions de conflits beaucoup plus difficiles</li>
				</ul>
			</section>


			<section>
				<h5>TP3 Commandes Git de base</h5>
				<p class="note">Voir la feuille de travaux pratiques</p>
			</section>

			<section>
				<h4>Les forges Git</h4>
				<ul>
					<li>GitHub (
						<a href="https://github.com/">https://github.com/</a>)</li>
					<li>BitBucket (
						<a href="https://bitbucket.org/">https://bitbucket.org/</a>)</li>
					<li>Forge privée : GitLab (
						<a href="https://gitlab.com/">https://gitlab.com/</a>)</li>
					<li>ou son clone point plume en Go : Gitea (
						<a href="https://gitea.io/">https://gitea.io/</a>)</li>
					
				</ul>
				<div>
					<img src="images/gitlab.png" />
					<figcaption>GitLab</figcaption>
				</div>
			</section>

			<section>
				<h4>Les pull requests (PR)</h4>
				<ul>
					<li>On créé une branche et on y commit ses modification</li>
					<li>On pousse les commits vers notre dépot personnel (Fork and pull) ou le dépot central (shared repository) sur la nouvelle
						branche
					</li>
					<li>On créé une PR (Pull Request)</li>
					<li>On en discute, si besoin on pousse de nouveaux commits. La PR continue à être alimentée.</li>
					<li>La PR est acceptée manuellement ou automatiquement (CI) dans le dépot de référence</li>
					<li>Voir
						<a ref='https://guides.github.com/introduction/flow/'>ce manuel Github</a>
					</li>
				</ul>
			</section>

			<section>
				<h3>Les workflows les plus courants</h3>
				<ul>
					<li>Gitflow</li>
					<li>Trunked-based</li>					
				</ul>
				<p class='note'>
					Voir aussi
					<span class='lcode'>man gitworkflows</span>
				</p>
			</section>

			<section>
				<h4>Gitflow (1/2)</h4>
				<img src="images/git-flow.png" style="width: 400px; margin: 5px" />
				<p style="font-size:0.5em">Copyright Vincent Driessen</p>
			</section>

			<section>
				<h4>Gitflow (2/2)</h4>
				<ul>
					<li>Feature branches + branche de release et hotfix</li>
					<li>Chaque commit de master = une version de production</li>
					<li>Puissant mais complexe</li>
					<li>Pas adapté pour gérer les branches de maintenance</li>
				</ul>
			</section>

			<section>
				<h4>Trunked-based Developement (TBD)</h4>
				<img src="images/trunked_based.png" style="width: 800px; margin: 5px" />				
			</section>
			
			<section>
				<h5>TP4 Utilitaires Git</h5>
				<p class="note">Voir la feuille de travaux pratiques</p>
				<br />
			</section>

			<section>
				<h4>Non abordé dans ce cours</h4>
				<p class="note">
					Voir
					<a href="#/100">[4]</a> pour approfondir
				</p>
				<ul>
					<li>Détail des différents types de protocoles</li>
					<li>Les commandes plumbing</li>
					<li>L'administration server-side (gitolite, gitweb etc.)</li>
					<li>Les hooks client et serveur</li>
					<li>La gestion des contributions exterieures (
						<span class='lcode'>git format-patch</span>,
						<span class='lcode'>git request-pull
						</span> et
						<span class='lcode'>git am</span>)
					</li>
					<li>Les attributs (comportement spécifique par chemin)</li>
					<li>Les sous-modules</li>
					<li>L'adaptateur
						<span class='lcode'>git-svn</span>
					</li>
					<li>...</li>
				</ul>
			</section>

			<!-- References, doit être la dernière page pour que les ancres fonctionnent -->
			<section>
				<h4>Références</h4>
				<ul>
					<li>[1] Git-flow :
						<a href="https://danielkummer.github.io/git-flow-cheatsheet/">https://danielkummer.github.io/git-flow-cheatsheet/</a>
					</li>
					<li>[4] Pro-git :
						<a href="http://git-scm.com/book">http://git-scm.com/book</a>. Version fr :
						<a href="http://git-scm.com/book/fr">http://git-scm.com/book/fr/</a>.
					</li>
					<li>[5] Git cheat sheet :
						<a href="http://ndpsoftware.com/git-cheatsheet.html">http://ndpsoftware.com/git-cheatsheet.html</a>
					</li>
					<li>[7] Script d'autocomplétion git :
						<a href="https://raw.github.com/git/git/master/contrib/completion/git-completion.bash">https://raw.github.com/git/git/master/contrib/completion/git-completion.bash</a>
					</li>
					<li>[10] A Visual Git Reference :
						<a href="http://marklodato.github.io/visual-git-guide/index-en.html">http://marklodato.github.io/visual-git-guide/index-en.html</a>
					</li>
					<li>[11] Git Ready (astuces et références vers docs) :
						<a href="http://gitready.com/">http://gitready.com/</a>
					</li>
					<li>[12] Typologies de workfow par Atlassian :
						<a href="https://www.atlassian.com/fr/git/workflows#!workflow-feature-branch">https://www.atlassian.com/fr/git/workflows#!workflow-feature-branch</a>
					</li>
					<li>[13] Tutorial interactif sur les branches avec Git :
						<a href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a>
					</li>
				</ul>
			</section>
		</div>
	</div>

<script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        width: 1400,
        height: 1000,
        progress: true,
        slideNumber: true,
        hash: true, 
        center: false,        
        plugins: [RevealHighlight]
      });
    </script>
  </body>
</html>
